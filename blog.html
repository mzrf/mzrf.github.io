<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>mz.blog</title>
    <style type="text/css">
        * { margin: 0; padding: 0; box-sizing: border-box;}
        a{text-decoration: none;color:#0366d6;}
        .hide{display:none !important}.show{display:block !important;}
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        html::-webkit-scrollbar,body::-webkit-scrollbar,html::-webkit-scrollbar { display: none;}
        #toc::-webkit-scrollbar,body::-webkit-scrollbar,html::-webkit-scrollbar { display: none;}
        nav { position: fixed; top: 0; left: 0; right: 0; height: 3rem; color: #222; background: #fdfdfd; display: flex; align-items: center; gap: 2rem; padding: 0 1rem; z-index: 1000; border-bottom: 1px solid #e0e0e0; }
        nav a {color: #0366d6; display: flex; align-items: center; }
        .label { margin-left: 0.3rem; font-size: 0.9rem; }
        main { margin-top: 3rem; min-height: calc(100vh - 3rem); overflow-y: auto;padding:1rem; background: #f9f9f9; display: flex;justify-content: space-around; }
        .aside {position: fixed;top:4rem;bottom:1rem;width:20rem;min-height:10rem;background:#fff;padding:1rem;border-radius: 0.5rem}
        #toc{left:1rem;overflow-y:auto;}#right{right:1rem}
        #toc a{display:inline-block;width:100%}
        #toc li{list-style:no;padding:0.25rem;}
        #toc li:hover{color: #1a5fd0;background:#e8f0fe;padding:0.5rem 0.25rem;}
        #right li:hover{color: #1a5fd0;background:#e8f0fe;padding:0.5rem 0.25rem;}
        #right li{display:flex;justify-content:space-between;padding:0.25rem}
        #toc li::marker{content:none}
        /*#toc ul,#toc li{list-style:none;padding-left: 1rem;position: relative;}
        #toc ul::before{content: '';position:absolute;top:0;left:0.5rem;bottom:0;width:1px;background:#ccc}
        #toc ul>li{position:relative;padding-left:1rem;margin:0.5rem 0;cursor:pointer;}
        #toc ul>li::before{content:'';position:absolute;top:0.5rem;left:0;width:0.5rem;height:1px;background:#ccc}
        #toc li:hover{background:#f9f9f9;}*/
        .main {width:calc(100vw - 44rem);padding:1rem;border-radius: 0.5rem}
        .mermaid { text-align: center; margin: 1rem 0; }
        .preview pre { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
        .preview pre code { background: none; padding: 0; }
        .katex { font-size: 1.1em; }
        .katex-display { margin: 1rem 0; text-align: center;}
        .mermaid svg { max-width: 100%; height: auto; }
        #toctoggle{position:fixed;bottom:5rem;left:50%;transform:translate(-50%);font-size:2rem;display:block;border-radius:1.5rem;border:1px solid #e0e0e0;background:#d0d7de;opacity:0.9;width:3rem;height:3rem;text-align:center;text-decoration:none;}
        #toctoggle:hover{opacity:1;}

        @media (max-width: 1380px) {
            #toc{display:none}
            #toctoggle{display:show !important}
            main{justify-content:flex-start;}
            .main{width:calc(100vw - 23rem)}
        }
        @media (max-width: 960px) {
            #toc{display:none}
            #toctoggle{display:show !important}
            .main{width:calc(100vw - 2rem)}
            #right{position:static;width:calc(100vw - 2rem);margin-top:1rem;}
            main{justify-content:space-around;flex-wrap: wrap;}
        }
        @media (max-width: 600px) {
            #toctoggle{display:none !important}
            nav a{font-size:1.2rem}
            nav { justify-content: space-around; }
            nav .label { display: none; }
            main{justify-content:space-around;flex-wrap: wrap;}
            #toc{display:none;}
            #preview{font-size:14px !important}
            .main,aside{width:calc(100vw - 2rem ),font-size:0.9rem}
            .main ul{padding-left: 1rem !important}
            .main img{margin:0 auto !important}
        }
    </style>
    <!-- CSS 库 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css">
</head>
<body>
    <nav>
        <a href="index.html"><span class="icon">🏠</span><span class="label">主页</span></a>
        <a href="blog.html"><span class="icon">📘</span><span class="label">博客</span></a>
        <a href="archive.html"><span class="icon">📚</span><span class="label">归档</span></a>
        <a href="about.html"><span class="icon">👤</span><span class="label">关于</span></a>
    </nav>
    <a href="javascript:;"id="toctoggle"class="toctoggle hide">≡</a>
    <main>
        <aside class="aside"id="toc"></aside>
        <div class="main preview markdown-body" id="preview"></div>
        <aside class="aside"id="right"></aside>
    </main>
    <!-- JavaScript 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/5.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.1/mermaid.min.js"></script>
    <script type="text/javascript">
    const toc = document.getElementById('toc');
    const menuBtn = document.getElementById('toctoggle');
    // 菜单按钮点击逻辑：显示或隐藏目录
    menuBtn.addEventListener('click', function(event) {
        toc.classList.add("show")
        menuBtn.classList.add("hide")
        event.stopPropagation()
        //toc.style.display = toc.style.display === 'none' || toc.style.display === '' ? 'block' : 'none';
    });

    // 监听点击事件
    document.addEventListener('click', function(event) {
        // 检查点击的元素是否是#toc内的链接
        const width = window.innerWidth;
        if(width<1380){
            const isTocLink = event.target.closest('#toc a');

            // 如果点击的不是#toc内的链接，隐藏#toc
            if (!isTocLink && !event.target.closest('#toctoggle')) {
                toc.classList.remove("show")
            } else if (isTocLink) {
                // 如果点击的是#toc内的链接，跳转到指定位置并隐藏#toc
                const targetId = isTocLink.getAttribute('href').substring(1); // 获取目标id
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                    setTimeout(() => {
                        window.scrollBy(0, -3 * parseFloat(getComputedStyle(document.documentElement).fontSize)); // 3rem向上滚动
                    }, 50);
                }
                toc.classList.remove("show")
            }
            menuBtn.classList.remove("hide")
            event.stopPropagation()
        }
        
        
    });
        document.addEventListener('DOMContentLoaded', function () {        
            
    });


        // if (!isTocLink) {
        //     // 如果点击的不是#toc内的链接，隐藏#toc
        //     toc.classList.add("hide")
        // } else {
        //     // 如果点击的是#toc内的链接，跳转到指定位置并隐藏#toc
        //     const targetId = isTocLink.getAttribute('href').substring(1); // 获取目标id
        //     const targetElement = document.getElementById(targetId);
        //     if (targetElement) {
        //         targetElement.scrollIntoView({ behavior: 'smooth' });
        //     }
        //     toc.classList.add("hide")
        // }

        class MarkdownRenderer {
            constructor() {
                this.preview = document.getElementById('preview');
                this.tocElement = document.getElementById('toc');
                this.mermaidCounter = 0;
                this.loadMarkdownFromURL();
            }

            // 初始化 marked 和 mermaid 配置
            initializeLibraries() {
                marked.setOptions({
                    highlight: function (code, lang) {
                        if (lang && hljs.getLanguage(lang)) {
                            try {
                                return hljs.highlight(code, { language: lang }).value;
                            } catch (err) {
                                console.warn('语法高亮错误:', err);
                            }
                        }
                        return hljs.highlightAuto(code).value;
                    },
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    headerPrefix: 'section-'
                });

                mermaid.initialize({
                    startOnLoad: false,
                    theme: 'default',
                    themeVariables: {
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                        fontSize: '14px'
                    },
                    flowchart: { useMaxWidth: true, htmlLabels: true },
                    sequence: { useMaxWidth: true, actorMargin: 50 }
                });
            }

            // 从 URL 获取 Markdown 文件
            async loadMarkdownFromURL() {
                const params = new URLSearchParams(window.location.search);
                const mdFileName = params.get('p') || 'p/readme.md';

                try {
                    const response = await fetch(mdFileName);
                    if (!response.ok) throw new Error('无法加载文件');
                    const markdownText = await response.text();
                    this.render(markdownText);
                } catch (error) {
                    console.error('错误:', error);
                    this.showError('加载错误', `无法加载文件 ${mdFileName}`);
                }
            }

            // 渲染 Markdown 和 TOC
            async render(markdown) {
                if (!markdown.trim()) {
                    this.preview.innerHTML = '<div class="loading">请输入 Markdown 文本...</div>';
                    return;
                }

                const toc = this.generateTOC(markdown);
                this.tocElement.innerHTML = toc;

                // 预处理 Mermaid 代码块
                const processedMarkdown = this.preprocessMermaid(markdown);

                // 渲染 Markdown 内容
                let html = marked.parse(processedMarkdown);
                html = await this.renderMath(html);
                this.preview.innerHTML = html;

                // 渲染 Mermaid 图表
                await this.renderMermaid();
            }

            // 生成目录
            generateTOC(markdown) {
                const headings = markdown.match(/^(#{1,6})\s(.+)$/gm);
                if (!headings) return '<ul><li>没有发现标题</li></ul>';

                return headings.reduce((toc, heading) => {
                    const level = heading.match(/^#{1,6}/)[0].length;
                    const text = heading.replace(/^#{1,6}\s/, '');
                    const id = text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '');
                    return toc + `<li style="margin-left: ${level - 1}em;"><a href="#${id}">${text}</a></li>`;
                }, '<ul>') + '</ul>';
            }

            // 预处理 Mermaid 代码块
            preprocessMermaid(markdown) {
                this.mermaidCounter = 0;
                return markdown.replace(/```mermaid\n([\s\S]*?)\n```/g, (match, code) => {
                    const id = `mermaid-${this.mermaidCounter++}`;
                    return `<div class="mermaid" id="${id}">${code.trim()}</div>`;
                });
            }

            // 渲染 Mermaid 图表
            async renderMermaid() {
                const mermaidElements = this.preview.querySelectorAll('.mermaid');
                for (const element of mermaidElements) {
                    try {
                        const graphDefinition = element.textContent.trim();
                        const { svg } = await mermaid.render(element.id + '-svg', graphDefinition);
                        element.innerHTML = svg;
                    } catch (error) {
                        console.error('Mermaid 渲染错误:', error);
                        element.innerHTML = `<div class="error-message">
                            <strong>Mermaid 图表渲染错误:</strong>
                            ${error.message}
                        </div>`;
                    }
                }
            }

            // 渲染 LaTeX 数学公式
            async renderMath(html) {
                try {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;

                    renderMathInElement(tempDiv, {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false },
                            { left: '\\(', right: '\\)', display: false },
                            { left: '\\[', right: '\\]', display: true }
                        ],
                        throwOnError: false,
                        errorColor: '#cc0000',
                        strict: 'ignore'
                    });

                    return tempDiv.innerHTML;
                } catch (error) {
                    console.error('LaTeX 渲染错误:', error);
                    return html;
                }
            }

            // 显示错误信息
            showError(title, message) {
                this.preview.innerHTML = `
                    <div class="error-message">
                        <strong>${title}</strong>
                        ${message}
                    </div>
                `;
            }
        }
        document.addEventListener('DOMContentLoaded', () => new MarkdownRenderer());
              // 从 list.json 动态加载数据
  fetch('list.json')
    .then(response => response.json())
    .then(listData => {
      // 1. 按照日期进行降序排序（从最新的开始）
      listData.sort((a, b) => new Date(b[1]) - new Date(a[1]));

      // 2. 获取最新的 10 个博客
      const latestBlogs = listData.slice(0, 10);

      // 3. 获取 #latest 元素
      const latestContainer = document.getElementById('right');
      latestContainer.innerHTML = ''; // 清空现有内容

      // 4. 遍历最新的博客并生成内容
      latestBlogs.forEach(blog => {
        const fileName = blog[0]; // 文件名
        const date = new Date(blog[1]); // 获取日期
        //const formattedDate = `${date.getMonth() + 1}-${date.getDate()}`; // 格式化日期为 MM-DD
        const month = (date.getMonth() + 1).toString().padStart(2, '0'); // 格式化月份为两位数
        const day = date.getDate().toString().padStart(2, '0'); // 格式化日期为两位数
        const formattedDate = `${month}-${day}`; // 格式化日期为 MM-DD

        // const formattedDate = `${month}-${day}`
        // 创建 <li> 元素
        const listItem = document.createElement('li');

        // 创建链接，并显示文件名和日期
        listItem.innerHTML = `
          <a href="blog.html?p=p/${fileName}">${fileName}</a> 
          <i class="date">${formattedDate}</i>
        `;

        // 将 <li> 元素添加到 #latest 中的 <ul> 元素里
        latestContainer.appendChild(listItem);
      });
    })
    .catch(error => console.error('Error loading list.json:', error));
    </script>
</body>
</html>
